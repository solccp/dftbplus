!--------------------------------------------------------------------------------------------------!
!  DFTB+: general package for performing fast atomistic simulations                                !
!  Copyright (C) 2018  DFTB+ developers group                                                      !
!                                                                                                  !
!  See the LICENSE file for terms of usage and distribution.                                       !
!--------------------------------------------------------------------------------------------------!

#:include 'common.fypp'

!> Angular momentum related routines
module angmomentum
#:if WITH_SCALAPACK
  use scalapackfx
#:endif
  use assert
  use accuracy, only : dp
  use constants, only : imag
  use qm
  use commontypes, only : TOrbitals
  use environment
  use densedescr
  implicit none
  private

  public :: getLOperators, getLOperatorsForSpecies
  public :: getLOnsite, getLDual


contains


  !> Returns L^+ and L_z in the tesseral spherical Harmonics basis used in DFTB+
  subroutine getLOperators(ll, Lplus, Lz)

    !> value of the orbital momentum to construct these matrices
    integer, intent(in) :: ll

    !> L^+ operator
    complex(dp),intent(out) :: Lplus(0:, 0:)

    !> L_z operator
    complex(dp),intent(out) :: Lz(0:, 0:)

    ! magnetic quantum number
    integer :: mm

    complex(dp), allocatable :: uu(:,:)

    @:ASSERT(ll >= 0)
    @:ASSERT(all(shape(Lplus) == shape(Lz)))
    @:ASSERT(size(Lplus, dim=1) == 2 * ll + 1)
    @:ASSERT(size(Lplus, dim=2) == 2 * ll + 1)

    ! L_z in usual spherical harmonic basis
    Lz(:,:) = 0.0_dp
    do mm = -ll, ll
      Lz(ll + mm, ll + mm) = real(mm, dp)
    end do

    ! L^+ in usual spherical harmonic basis
    Lplus(:,:) = 0.0_dp
    do mm = -ll, ll - 1
      Lplus(ll + mm + 1, ll + mm) = sqrt(real(ll * (ll + 1) - mm * (mm + 1), dp))
    end do

    allocate(uu(0 : 2 * ll, 0 : 2 * ll))

    ! unitary transformation from Y_{lm} to \overline{Y}_{lm}
    uu(:,:) = 0.0_dp
    do mm = 1, ll
      uu(ll + mm, ll  + mm) = sqrt(0.5_dp) * real(mod(mm + 1, 2)-mod(mm, 2), dp)
      uu(ll + mm, ll - mm) = sqrt(0.5_dp)
      uu(ll - mm, ll + mm) = -sqrt(0.5_dp) * imag * real(mod(mm, 2) - mod(mm + 1, 2), dp)
      uu(ll - mm, ll - mm) = -sqrt(0.5_dp) * imag
    end do
    uu(ll, ll) = 1.0_dp

    call makeSimiliarityTrans(Lz, uu)
    call makeSimiliarityTrans(Lplus, uu)

  end subroutine getLOperators


  !> Returns Lz and Lplus for a given species.
  subroutine getLOperatorsForSpecies(orb, iSpecies, speciesZ, speciesPlus)

    !> Orbital information
    type(TOrbitals), intent(in) :: orb

    !> Species to get the operators for
    integer, intent(in) :: iSpecies

    !> Species specific Lz operator
    complex(dp), intent(out) :: speciesZ(:,:)

    !> Species specific L+ operator
    complex(dp), intent(out) :: speciesPlus(:,:)

    integer :: iShell, ll, nOrbShell, iOrbStart, iOrbEnd

    @:ASSERT(all(shape(speciesZ) == shape(speciesPlus)))

    speciesZ(:,:) = 0.0_dp
    speciesPlus(:,:) = 0.0_dp
    do iShell = 1, orb%nShell(iSpecies)
      ll = orb%angShell(iShell, iSpecies)
      nOrbShell = 2 * ll + 1
      iOrbStart = orb%posShell(iShell, iSpecies)
      iOrbEnd = orb%posShell(iShell + 1, iSpecies) - 1
      call getLOperators(ll, speciesPlus(1:nOrbShell, 1:nOrbShell),&
          & speciesZ(1:nOrbShell, 1:nOrbShell))
    end do

  end subroutine getLOperatorsForSpecies


  !> Calculates the on-site orbital angular momentum
  subroutine getLOnsite(env, Lshell, rho, denseDesc, orb, species)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> resulting orbital angular momentum (cartesian component, atomic shell, atom)
    real(dp), intent(out) :: Lshell(:,:,:)

    !> Density matrix
    complex(dp), intent(in) :: rho(:,:)

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Information about the orbitals in the system.
    type(TOrbitals), intent(in) :: orb

    !> Species of the atoms
    integer, intent(in) :: species(:)

    integer :: nAtom, nSpecies, nOrb, nOrbSp
    integer :: iSp, iAt, iShell, iOrb, iOrbStart, iOrbEnd, kk
    complex(dp), allocatable :: speciesL(:,:,:,:)
    complex(dp) :: speciesPlus(orb%mOrb, orb%mOrb), speciesZ(orb%mOrb, orb%mOrb)
    complex(dp) :: tmpBlock(orb%mOrb, orb%mOrb)

    nAtom = size(Lshell, dim=3)
    nSpecies = maxval(species(1:nAtom))
    nOrb = size(rho, dim=1)

    @:ASSERT(size(denseDesc%iAtomStart) == nAtom + 1)
    @:ASSERT(mod(nOrb,2) == 0)
    nOrb = nOrb / 2

    allocate(speciesL(orb%mOrb, orb%mOrb, 3, nSpecies))
    speciesL(:,:,:,:) = 0.0_dp
    do iSp = 1, nSpecies
      call getLOperatorsForSpecies(orb, iSp, speciesPlus, speciesZ)
      speciesL(:, :, 1, iSp) = 0.5_dp * (speciesPlus + transpose(conjg(speciesPlus)))
      speciesL(:, :, 2, iSp) = 0.5_dp * imag * (transpose(conjg(speciesPlus) - speciesPlus))
      speciesL(:, :, 3, iSp) = speciesZ
    end do

    Lshell(:,:,:) = 0.0_dp

    do iAt = 1, nAtom
      iSp = species(iAt)
      nOrbSp = orb%nOrbSpecies(iSp)
      iOrbStart = denseDesc%iAtomStart(iAt)
      iOrbEnd = denseDesc%iAtomStart(iAt + 1) - 1

      ! I block
      tmpBlock(:,:) = 0.0_dp
    #:if WITH_SCALAPACK
      call scalafx_addg2l(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, iOrbStart, iOrbStart, rho,&
          & tmpBlock(1:nOrbSp, 1:nOrbSp))
      call scalafx_addg2l(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, nOrb + iOrbStart,&
          & nOrb + iOrbStart, rho, tmpBlock(1:nOrbSp, 1:nOrbSp))
    #:else
      tmpBlock(1:nOrbSp, 1:nOrbSp) = rho(iOrbStart:iOrbEnd, iOrbStart:iOrbEnd) &
          & + rho(nOrb + iOrbStart : nOrb + iOrbEnd, nOrb + iOrbStart : nOrb + iOrbEnd)
    #:endif
      tmpBlock(:,:) = 0.5_dp * tmpBlock
      ! Hermitize
      do iOrb = 1, nOrbSp
        tmpBlock(iOrb, iOrb + 1 :) = conjg(tmpBlock(iOrb + 1 :, iOrb))
      end do
      do iShell = 1, orb%nShell(iSp)
        iOrbStart = orb%posShell(iShell, iSp)
        iOrbEnd = orb%posShell(iShell + 1, iSp) - 1
        do kk = 1, 3
          Lshell(kk, iShell, iAt) = Lshell(kk, iShell, iAt) + &
              & real(sum(speciesL(iOrbStart:iOrbEnd, iOrbStart:iOrbEnd, kk, iSp)&
              & * transpose(tmpBlock(iOrbStart:iOrbEnd, iOrbStart:iOrbEnd))), dp)
        end do
      end do

    end do

  end subroutine getLOnsite


  !> Calculates the on-site orbital angular momentum for dual populations
  subroutine getLDual(Lshell, qBlockSkew, orb, species)

    !> resulting orbital angular momentum (cartesian component, atomic shell, atom)
    real(dp), intent(out) :: Lshell(:,:,:)

    !> Antisymmetric Mulliken block populations for imaginary coefficients of Pauli matrics
    real(dp), intent(in) :: qBlockSkew(:,:,:,:)

    !> Information about the orbitals in the system.
    type(TOrbitals), intent(in) :: orb

    !> Species of the atoms
    integer, intent(in) :: species(:)

    integer :: nAtom, nSpecies, nOrbSp
    integer :: iAt, iSp, iOrb, iOrbStart, iOrbEnd, kk
    real(dp), allocatable :: speciesL(:,:,:,:)
    complex(dp) :: speciesPlus(orb%mOrb, orb%mOrb), speciesZ(orb%mOrb, orb%mOrb)
    real(dp), allocatable :: tmpBlock(:,:)

    complex(dp), parameter :: i = (0.0_dp,1.0_dp)

    nAtom = size(LShell, dim=3)
    nSpecies = maxval(species(1:nAtom))

    allocate(speciesL(orb%mOrb, orb%mOrb, 3, nSpecies))
    do iSp = 1, nSpecies
      call getLOperatorsForSpecies(orb, iSp, speciesPlus, speciesZ)
      speciesL(:, :, 1, iSp) = aimag(speciesPlus)
      speciesL(:, :, 2, iSp) = -real(speciesPlus)
      speciesL(:, :, 3, iSp) = aimag(speciesZ)
    end do

    allocate(tmpBlock(orb%mOrb, orb%mOrb))

    Lshell(:,:,:) = 0.0_dp
    do iAt = 1, nAtom
      iSp = species(iAt)
      nOrbSp = orb%nOrbSpecies(iSp)
      tmpBlock(:,:) = 0.0_dp
      ! Identity part
      tmpBlock(1:nOrbSp, 1:nOrbSp) = qBlockSkew(1:nOrbSp, 1:nOrbSp, iAt, 1)
      do iOrb = 1, orb%nShell(iSp)
        iOrbStart = orb%posShell(iOrb, iSp)
        iOrbEnd = orb%posShell(iOrb + 1, iSp) - 1
        do kk = 1, 3
          Lshell(kk, iOrb, iAt) = Lshell(kk, iOrb, iAt)&
              & - sum(speciesL(iOrbStart:iOrbEnd, iOrbStart:iOrbEnd, kk, iSp)&
              & * transpose(tmpBlock(iOrbStart:iOrbEnd, iOrbStart:iOrbEnd)))
        end do
      end do
    end do

  end subroutine getLDual


end module angmomentum
